* DONE Move talk into yada talks
* TODO Merge in existing talk from 2 places                             :bus:
- [ ] Life.org
- [ ] yada's todo.org
* TODO How to hide reveal headings?
* TODO Can regen custom CSS?
** TODO sassc
* TODO Code highlighting

<!-- Code syntax highlighting -->
<link rel="stylesheet" href="static/css/zenburn.css">


reveal deps not being generated?

#+BEGIN_SRC javascript
  // Optional reveal.js plugins
  dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'static/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'static/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'static/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'static/plugin/zoom-js/zoom.js', async: true },
          { src: 'static/plugin/notes/notes.js', async: true }
  ]

#+END_SRC



* TODO Speaker notes



* Talk
also see talk in file:/home/malcolm/src/yada/todo.org

** Intro

Title:

yada. Resources as Data

We love Ring. Why? Requests as Data, Responses as Data.
With routing libraries like Pedestal, bidi and silk, we can have Routes as Data

I was inspired to write something like yada after Tommi Riemann's talk last year in Poland.

He created Swagger on compojure, and mentioned that something similar could be done with bidi.
But I realised that would be trivial for swagger routes, but certainly not trivial for other swagger data, unless we had some way of describing web resources, as data.

so in some ways, yada completes the square - we have requests, responses, routes and, with yada, resources was data.

And actually I think we've really missed out on not doing the Clojure thing and using data to describe our resources.

Let's me explain with some examples.

1. compojure
2. wrap-head
3. wrap-modified

what's the problem? why can't we do a better job? what are we missing here? Answer: DATA
With ring middleware, all we get at the end is a composed function

** Function opacity
“Arthur Dent: What happens if I press this button?
Ford Prefect: I wouldn't-
Arthur Dent: Oh.
Ford Prefect: What happened?
Arthur Dent: A sign lit up, saying 'Please do not press this button again.”
― Douglas Adams, The Original Hitchhiker Radio Scripts

That's the exact interface that composed functions give us.

Everyone goes crazy about function composition, but I think it's a very poor substitute for data composition.

** yada

Let me show you what things look like when you inject data back in to web resources.

So let's start with some data: a string: (-> "Hello World!").

We love Ring right? Requests as data, responses as data....

So let's turn our data into a Ring handler. (-> "Hello World!" yada).

What does that give us?

(pprint (yada "Hello World!")).


(aside, what if we did this: (-> "Hello World!" yada yada) - do we automatically get swagger???
(and this: (-> "Hello World!" yada yada yada) - ) - do get the swagger of the handler that serves the swagger spec. of the Hello World resource.


** word cloud
https://www.jasondavies.com

list of words



** ClojureTRE
*** What's good about HTTP?

Designed for long-lived services
Mature and widely implemented (proxies, browsers, servers, firewalls, etc.)
Since last year, new clearer specs. RFC 7231 etc.
Mostly people's definition of REST is 'use HTTP as specified' (rather than hypermedia APIs).

*** The limits of Ring

**** Methods

(GET "/name" [] "Malcolm")

What will this return?

curl -X PUT /name

404 is the right answer
but it should be 405

A cache or user-agent might see the 404 and think there is no representation for that resource, so would perhaps not try a future GET

**** wrap-head

For example, Ring offers middleware, namely
`ring.middleware.head/wrap-head`, to support the implementation of HEAD
requests. However, the implementation requires that a full GET request
is made, from which the response body is truncated. Therefore, HEAD
requests are always at least as expensive as GET requests. This is
certainly not what the authors of HTTP had in mind.

Imagine you were

**** wrap-not-modified

Similarly, Ring's `wrap-not-modified` function only runs _after_ the
response has been fully formed. The whole point of this HTTP feature is
to remove load from the origin server. However, if the entire response
has to be recreated each time, there are no advantages to using this
feature.

**** But yada fixes all this, and more

*** yada features
**** Content negotiation
all permutations of media-types, charsets, languages, encoding
proactive negotiation, vary,
reactive negotiation
custom media-types,
json,edn,yaml,transit, etc.
**** Conditional requests
etags use clojure (hash)
collision detection
**** Methods
allowed-methods, 405, options
custom methods (via protocols), known-methods
method proxies to ensure HTTP semantics
**** Parameters
path (implicit bidi), query, header, form, body and cookie types
**** Swagger
(mention yada was influced by Tommi's Krakow talk)
show yada's swagger code which demonstrates the call to ring-swagger, use of protocols and representations

#+BEGIN_SRC clojure
(defrecord SwaggerSpec [spec content-type created-at]

  Representations
  (representations [_]
    (case content-type
      "application/json" [{:media-type #{"application/json"
                                         "application/json;pretty=true"}
                           :charset #{"UTF-8" "UTF-16;q=0.9" "UTF-32;q=0.9"}}]

      "application/edn" [{:media-type #{"application/edn"
                                        "application/edn;pretty=true"}
                          :charset #{"UTF-8"}}]

      "text/html" [{:media-type "text/html"
                    :charset charset/platform-charsets}]))

  Get
  (GET [_ ctx] (ring.swagger.swagger2/swagger-json spec))

  ResourceModification
  (last-modified [_ ctx] created-at)

  ResourceVersion
  (version [_ ctx] spec))

#+END_SRC

This is code INSIDE yada, making use of yada, it's typical of the size of many of these resources.
The record defines different types of resource, based on content-type

Points to make:
For application/json, there are actually 2x3=6 representations here, including pretty printing
For application/edn, there are just 2
swagger-json returns a data-structure, yada coerces it to json
text/html coerced via json-html library

**** Async
Get database result
Service availability
Not forgetting realtime (sse)

#+BEGIN_SRC clojure
  (resource (chan) {:access-control {:allow-origin "*"}})
#+END_SRC

**** And much more
Prefer
Reactive negotiation
Partial content
Large files (uploads, downloads)
Expectations
Range requests
Rate limiting

Ring middleware
Great bidi integration
Security (bolt)
yada-cache
yada-test
yada-trace

**** Data centric
protocols, records - 'resources as data'
postwalk bidi structures, fiddle the interceptor chain

*** That's great, but how do I use yada? yada examples

There's just one function: resource

#+BEGIN_SRC clojure
(resource "Hello World!")

;; Types determine yada's behaviour
(resource (atom "Hello World!"))

;; You can create your own custom types - just satisfy some protocols!
(resource (map->PostgresTable {:table "ACCOUNTS"}))

;; Ordinary functions are types too!
;; But you're more likely to need to add options
(resource (fn [ctx] (case (:method ctx)...))
          {:allowed-methods #{:get :post}})
#+END_SRC

*** Conclusion
HTTP is great, use it!
Build ON, not up to, HTTP compliance
yada can help

Go write (less) code!
