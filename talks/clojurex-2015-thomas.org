#+EXPORT_EXCLUDE_TAGS:  noexport
#+AUTHOR:               Thomas van der Veen
#+TITLE:                Clojure and REST Full Web
#+EMAIL:                @thomasvdv007
#+LANGUAGE:             en
#+OPTIONS:              toc:nil
#+OPTIONS:              reveal_center:t reveal_progress:t reveal_history:t reveal_control:nil
#+OPTIONS:              reveal_mathjax:nil reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS:              width:1600 height:900
#+REVEAL_HLEVEL:        1
#+REVEAL_MARGIN:        0.0
#+REVEAL_MIN_SCALE:     1.0
#+REVEAL_MAX_SCALE:     1.4
#+REVEAL_THEME:         base
#+REVEAL_TRANS:         fade
#+REVEAL_SPEED:         fast
#+REVEAL_ROOT:          static
#+REVEAL_PLUGINS: (highlight markdown notes)
#+REVEAL_EXTRA_CSS: static/css/extra.css

** Acceptance Criteria

- List all entries in the phone book
- Create a new entry in the phone book
- Remove an existing entry from the phone book
- Update an existing entry in the phone book
- Search for entries by surname
- An entry has the following
 - Surname
 - First name
 -Address

** CRUD

Create: POST

Read: GET

Update: PUT

Delete: DELETE

** Compojure Routes

#+BEGIN_SRC clojure
  (defroutes app-routes
    (GET "/v1/phonebook" [ ] (get-phonebook))
    (POST "/v1/phonebook" {body :body}
          (add-user (slurp body)))
    (PUT "/v1/phonebook/:id"
         {body :body params :params}
         (update-user (:id params)
                      (slurp body)))
    (DELETE "/v1/phonebook/:id" [id]
            (delete-user id))
    (GET "/v1/phonebook/search"
         {params :params}
         (search-users params))
    (route/not-found "Not Found"))
#+END_SRC

** Our main data-structure

#+BEGIN_SRC clojure
  (def phonebook
    {"80a8ea00-…"
     {:first-name "Thomas"
      :surname "van der Veen"
      :phonenumber "0783312345"
      :address {:street "High Street"
                 :postcode "SO21 1QQ"}}
     "38d77ce0-…"
     {:firstname "Malcolm"
      :surname "Sparks"
      :phonenumber "07123456"} }
    :last-added "38d77ce0-…"})
#+END_SRC

** Adding a new entry

#+BEGIN_SRC clojure
(defn atomic-user-add [db data]
  (let [new-uuid (.toString (UUID/randomUUID))
        new-db (assoc-in db [:db new-uuid] data)]
    (assoc-in new-db [:last-added] new-uuid )))

(defn add-user [data]
  (let [parsed-data (edn/read-string data)
        validated (validate parsed-data)]
    (if (contains? validated :valid)
      (do (let [{id :last-added}
                (swap! phonebook-db atomic-user-add parsed-data )]
            {:status 201 :body (pr-str id)}))
      {:status 400 :body (str "malformed request\n"
                              (:reason validated))})))
#+END_SRC

** Getting the entries

#+BEGIN_SRC clojure
  (defn get-phonebook []
    (let [data (pr-str (:db @phonebook-db))]
      (-> (r/response data)
          (r/content-type
           "application/edn"))))
#+END_SRC

** Updating an entry

#+BEGIN_SRC clojure
  (defn update-user [id data]
    (let [parsed-data (edn/read-string data)
          validated (validate parsed-data)]
      (if (contains? (:db @phonebook-db) id)
        (if (contains? validated :valid )
          (do
            (swap! phonebook-db assoc-in [:db id] parsed-data)
            {:status 200})
          {:status 400 :body (str "malformed request\n"
                                  (:reason validated))}))
      {:status 404 :body (str id " does not exist\n")})))
#+END_SRC

** Deleting an entry

#+BEGIN_SRC clojure
  (defn delete-user [id]
    (if (contains? (:db @phonebook-db ) id)
      (do (swap! phonebook-db update-in
                 [:db] dissoc id)
          {:status 200})
      {:status 404 :body
       (str id " does not exist\n")}))
#+END_SRC

** Searching for an entry

#+BEGIN_SRC clojure
  (defn search-users [params]
    (let [surname (:surname params)
          filtered (into {}
                         (filter
                          #(= surname (:surname (second %)))
                          (:db @phonebook-db)))]
      (-> (r/response (pr-str filtered))
          (r/content-type
           "application/edn"))))
#+END_SRC

** Validating input using Prismatic Schema

#+BEGIN_SRC clojure
  (def schema
    {:firstname s/Str
     :surname s/Str
     :phonenumber s/Str
     (s/optional-key :address)
     {:place s/Str
      :country s/Str}})
#+END_SRC

** Validating

#+BEGIN_SRC clojure
  (defn validate [data]
    (try
      (s/validate schema data)
      {:valid true}
      (catch Exception e
        {:invalid true :reason
         (.getMessage e)})))
#+END_SRC

* Some observations about Tom's code

** It's good.
- Simple & easy
- Idiomatic
** Only serves humans (who read English)
- Only supports HTML, encourages scraping
- Only English supported
- Would need more thinking to be an API
** Vulnerable to attack
- No security headers
- Ad-hoc parameter validation
** Blocking I/O
** No service metadata
- No data about what the service does (e.g. Swagger, RAML)
- No HEAD, OPTIONS or TRACE methods
** Doesn't support conditional requests
- Doesn't support If-Modified-Since (dates)
- Doesn't support If-Not-Match (etags)
- No cache-control headers
- No content-encoding (e.g. gzip)
** (diagram of Om/Next)

** Ad-hoc
- 'Hand-crafted'
- Hypermedia links are hand-coded
- Service can't be generated
- Leads to masses of brittle, duplicate code

** DON'T PANIC

- There are solutions for most of these issues
- Trouble is, things get /complex/
- How can we fix all these issues at once?

** Solution
  :PROPERTIES:
  :reveal_background: #f8f8f8
  :reveal_extra_attr: class="juxt_hide-heading"
  :END:

#+REVEAL_HTML: <span style="font-family: yada; font-size: 4em">yada</span>

* The phonebook index

#+BEGIN_SRC clojure
{:description "Phonebook index"
 :properties {…}
 :methods {:get {…}
           :post {…}}
#+END_SRC

** GET

#+BEGIN_SRC clojure
  {:get {:parameters {:query {(s/optional-key :q) String}}
         :produces {:media-type #{"text/html" "application/json;q=0.9"}
                    :charset "UTF-8"}
         :handler (fn [ctx]
                    (let [q (get-in ctx [:parameters :query :q])
                          entries (if q
                                    (db/search-entries db q)
                                    (db/get-entries db))]
                      (case (yada/content-type ctx)
                        "text/html" (html/index-html entries @*routes q)
                        entries)))}}
#+END_SRC

** POST

#+BEGIN_SRC clojure
  {:post
   {:parameters {:form {:surname String :firstname String :phone String}}
    :consumes {:media-type "multipart/form-data"
               :charset "UTF-8"}
    :handler (fn [ctx]
               (let [id (db/add-entry db (get-in ctx [:parameters :form]))]
                 (yada/redirect-after-post
                  ctx (path-for @*routes :phonebook.api/entry :entry id))))}}
#+END_SRC

* The phonebook entry

#+BEGIN_SRC clojure
{:description "Phonebook entry"
 :parameters {:path {:entry Long}}
 :methods {:get {…}
           :put {…}
           :delete {…}}}
#+END_SRC

** Phonebook entry GET

#+BEGIN_SRC clojure
  {:get
   {:produces
    {:media-type #{"text/html" "application/json;q=0.8"}
     :charset "UTF-8"}
    :handler
    (fn [ctx]
      (let [id (get-in ctx [:parameters :path :entry])
            {:keys [firstname surname phone] :as entry}
            (db/get-entry db id)]
        (when entry
          (case (get-in ctx [:response :representation :media-type :name])
            "text/html"
            (html/entry-html
             entry
             {:entry (path-for @*routes :phonebook.api/entry :entry id)
              :index (path-for @*routes :phonebook.api/index)})
            entry))))}}
#+END_SRC

** Phonebook entry DELETE

#+BEGIN_SRC clojure
  {:delete
   {:handler
    (fn [ctx]
      (let [id (get-in ctx [:parameters :path :entry])]
        (db/delete-entry db id)))}}
#+END_SRC

** Phonebook entry PUT

#+BEGIN_SRC clojure
  {:put
   {:parameters
    {:form {:surname String
            :firstname String
            :phone String}}
    :consumes {:media-type "multipart/form-data"}
    :handler
    (fn [ctx]
      (let [entry (get-in ctx [:parameters :path :entry])
            body (get-in ctx [:parameters :body])]
        (db/update-entry db entry body)))}}
#+END_SRC

* multipart/form-data

#+BEGIN_QUOTE
I don't really care about the minutia of what's involved here, but I'd
glad that someone with your level of OCD does.
#+END_QUOTE

* yada roadmap

(Tolkien map with location, somewhere around The Dead Marshes)


* Add
Allow
Vary

All these complaints are fully addressed by the library I'm going to
mention at the end.
